# Taken from https://gitlab.tune-it.ru/jackalope/dict-it/-/blob/dev/semnet/commons.cmake


set(CMAKE_CXX_STANDARD 17)

# Macro for declaring library build from source files
# Package options:
#   curdir - path to source files (from the root of project)
macro(add_package curdir)
    cmake_parse_arguments(
            PACKAGE_OPTIONS
            "STATIC;SHARED;FPIC"
            "SINGLE_TARGET"
            "TARGETS"
            ${ARGN}
    )
    set (extra_macro_args ${PACKAGE_OPTIONS_SINGLE_TARGET} ${PACKAGE_OPTIONS_TARGETS} ${PACKAGE_OPTIONS_UNPARSED_ARGUMENTS})
    # message(INFO ${PACKAGE_OPTIONS_UNPARSED_ARGUMENTS})
    message("Package ${extra_macro_args}")
    # Did we get any optional args?
    list(LENGTH extra_macro_args num_extra_args)
    set(optional_sources "")
    set(optional_targets "")
    set(optional_libs "")
    if (${num_extra_args} GREATER 0)
        foreach (i ${extra_macro_args})
            if(${i} MATCHES "^.*\\.cpp$|^.*\\.c$")
                #message ("Got an optional arg: ${i}")
                list(APPEND optional_sources ${i})
            elseif(TARGET ${i})
                list(APPEND optional_targets ${i})
            else()
                list(APPEND optional_libs ${i})
            endif()
        endforeach()
        message ("Got an optional sources: ${optional_sources}")
        message ("Got an optional targets: ${optional_targets}")
        message ("Got an optional libraries: ${optional_libs}")
        #list(GET extra_macro_args 0 optional_arg)
    endif ()
    file(GLOB sources "${src}/${curdir}/*.cpp" "${src}/${curdir}/*.c"
            "${src}/${curdir}/*.h" "${src}/${curdir}/*.hpp"
            "${src}/${curdir}/*.yy" "${src}/${curdir}/*.ll")
    #file(GLOB optional_sources "${src}/${optional_arg}/*.cpp" "${src}/${optional_arg}/*.c")
    foreach (s ${sources} ${optional_sources})
        message(${s})
    endforeach()
    get_filename_component(curdirname ${src}/${curdir} NAME)
    get_filename_component(curdirpath ${src}/${curdir} ABSOLUTE)
    list(LENGTH sources sources_length)
    message("curdirname: ${curdirname}")
    message("curdirpath: ${curdirpath}")
    message("total sources: ${sources_length}")

    if ((NOT ${PACKAGE_OPTIONS_STATIC}) AND (NOT ${PACKAGE_OPTIONS_SHARED}))
        set(${PACKAGE_OPTIONS_SHARED} "TRUE")
    endif()
    message("Static : ${PACKAGE_OPTIONS_STATIC}, shared : ${PACKAGE_OPTIONS_SHARED}, sources_length: ${sources_length}")

    if(${sources_length} GREATER "0")
        if (${PACKAGE_OPTIONS_STATIC})
            add_library(${curdirname} STATIC ${sources} ${optional_sources})
            add_library(${curdirname}_static ALIAS ${curdirname})
            if (${PACKAGE_OPTIONS_FPIC})
                set_property(TARGET ${curdirname} PROPERTY POSITION_INDEPENDENT_CODE ON)
            endif()
            target_include_directories(${curdirname} PUBLIC ${curdirpath})
        endif()

        if(${PACKAGE_OPTIONS_SHARED})
            if (NOT TARGET ${curdirname})
                set(aliasname ${curdirname}_shared)
            else()
                set(aliasname ${curdirname})
                set(curdirname ${curdirname}_shared)
            endif()

            add_library(${curdirname} SHARED ${sources} ${optional_sources})
            foreach(i ${optional_targets})
                if (TARGET ${i}_shared)
                    target_link_libraries(${curdirname} ${i}_shared)
                else()
                    if (APPLE)
                        target_link_libraries(${curdirname} -Wl,-force_load ${i} -Wl,-noall_load)
                    else()
                        target_link_libraries(${curdirname} -Wl,--whole-archive ${i} -Wl,--no-whole-archive)
                    endif()
                endif()
            endforeach()

            target_link_libraries(${curdirname} ${optional_libs})

            add_library(${aliasname} ALIAS ${curdirname})
            target_include_directories(${curdirname} PUBLIC ${curdirpath})
        endif()

        unset(optional_sources)

    endif()
endmacro()

macro(add_exec proj_name depends)
    add_executable(${proj_name} ${src}/${proj_name}.cxx)
    foreach (i ${depends})
        #message("link ${proj_name} with ${i}")
        get_filename_component(dir_name ${i} DIRECTORY)
        target_include_directories(${proj_name} PRIVATE ${src}/${dir_name})
        #message("${dir_name}")
        target_link_libraries(${proj_name} ${i})
    endforeach()
    #target_link_libraries(${proj_name} ${extra_libs})
endmacro()

#file(GLOB main_sources "${curdir}/*.cxx")
#foreach (s ${main_sources})
#    get_filename_component(proj_name ${s} NAME)
#    get_filename_component(dir_name ${s} DIRECTORY)
#    string(REGEX REPLACE "\\.[^.]*$" "" proj_name ${proj_name})
#    message(${dir_name})
#    add_executable(${proj_name} ${s})
#    subdirlist(cdir ${dir_name})
#    target_include_directories(${proj_name} PRIVATE ${dir_name})
#    foreach(c ${cdir})
#        message(${c})
#        target_include_directories(${proj_name} PRIVATE ${curdir}/${c})
#        target_link_libraries(${proj_name} ${c} ${exec_lib})
#    endforeach()
#endforeach()



#file(GLOB_RECURSE sources "${src}/*.cpp")
#file(GLOB_RECURSE main_sources "${src}/*.cxx")
#foreach (s ${main_sources})
#    get_filename_component(proj_name ${s} NAME)
#    string(REGEX REPLACE "\\.[^.]*$" "" proj_name ${proj_name})
#    #message(STATUS ${proj_name})
#    add_executable(${proj_name} ${sources} ${s})
#    target_link_libraries(${proj_name} ${Boost_LIBRARIES} pthread log4cplus)
#    #cotire(${proj_name})
#endforeach()

#get nonrecursive subdirs list from ${curdir}
macro(subdirlist result curdir)
    file(GLOB children RELATIVE ${curdir} ${curdir}/*)
    set(dirlist "")
    foreach(child ${children})
        if(IS_DIRECTORY ${curdir}/${child})
            #message(${child})
            list(APPEND dirlist ${child})
        endif()
    endforeach()
    set(${result} ${dirlist})
endmacro()

macro(all_subdirs result source)
    set(dirlist "")
    set(res "")
    list(APPEND dirlist ${source})
    list(LENGTH dirlist len)
    while (${len} GREATER 0)
        list(GET dirlist 0 curdir)
        file(GLOB children RELATIVE ${source} ${curdir}/*)
        message("Scan")
        message(${curdir})
        foreach(child ${children})
            if(IS_DIRECTORY ${source}/${child})
                list(APPEND dirlist ${source}/${child})
                list(APPEND res ${child})
            endif()
        endforeach()
        list(REMOVE_AT dirlist 0)
        list(LENGTH dirlist len)
    endwhile()
    set(${result} ${res})
endmacro()

#Copy all files from specified source to target
#Source relative path is treated with respect to the value of CMAKE_CURRENT_SOURCE_DIR
#Target relative path is treated with respect to the value of CMAKE_CURRENT_BINARY_DIR
#If target already exists and it is not CMAKE_CURRENT_BINARY_DIR, it will be removed
macro(configure_resources source target)
    if (NOT IS_ABSOLUTE ${source})
        set(abs_source ${CMAKE_CURRENT_SOURCE_DIR}/${source})
    else()
        set(abs_source ${source})
    endif()
    if (NOT IS_ABSOLUTE ${target})
        set(abs_target ${CMAKE_CURRENT_BINARY_DIR}/${target})
    else()
        set(abs_target ${target})
    endif()
    message(${abs_target})
    message(${abs_source})
    if (NOT EXISTS ${abs_source})
        message(SEND_ERROR "Source resources do not exist")
    else()
        if (EXISTS ${abs_target})
            message(remove)
            if (NOT ${abs_target} STREQUAL ${CMAKE_CURRENT_BINARY_DIR})
                file(REMOVE_RECURSE ${abs_target})
            endif()
        endif()
        if (NOT IS_DIRECTORY ${abs_source})
            message("Source is not directory")
            configure_file(${abs_source} ${abs_target} COPYONLY)
        else()
            file(MAKE_DIRECTORY ${abs_target})
            all_subdirs(subs ${abs_source})
            file(GLOB contents RELATIVE ${abs_source} ${abs_source}/*)
            foreach(child ${contents})
                if (NOT IS_DIRECTORY ${abs_target}/${child})
                    configure_file(${abs_source}/${child} ${abs_target}/${child} COPYONLY)
                endif()
            endforeach()
            foreach(sub ${subs})
                message(${sub})
                set(curdir ${abs_source}/${sub})
                set(targetdir ${abs_target}/${sub})
                file(MAKE_DIRECTORY ${targetdir})
                file(GLOB contents RELATIVE ${curdir} ${curdir}/*)
                foreach(child ${contents})
                    if (NOT IS_DIRECTORY ${curdir}/${child})
                        configure_file(${curdir}/${child} ${targetdir}/${child} COPYONLY)
                    endif()
                endforeach()
            endforeach()
        endif()
    endif()
endmacro()

macro(find_required_library target_var lib)
    message("Search for library ${lib}")
    find_library(${target_var} ${lib})
    if(${target_var} MATCHES "NOTFOUND")
        message(FATAL_ERROR "lib ${target_var}: not found")
    else()
        message("found lib: ${target_var}")
    endif()
endmacro()
